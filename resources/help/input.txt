Input selection:

--find

The absolute path of a file will be used for matching, and is passed to
the pattern if the pattern is a Callable.

--json-per-file

Attempt to parse the whole file as JSON.  If successful, pass this to the
pattern Callable.  Only files with the .json extension will be tried, unless
overridden by any explicit extension specification.

--json-per-elem

Attempt to parse the whole files as JSON.  If successful, pass each top-level
element to the pattern Callable.  Only files with the .json extension will be
tried, unless overridden by any explicit extension specification.

--json-per-line

Attempt to parse each line in the file as JSON.  If successful, pass this to
the pattern Callable.  Only files with the .jsonl extension will be tried,
unless overridden by any explicit extension specification.

--blame-per-file

Attempt to obtain "git blame" information of the file as a Git::Blame::File
object.  If successful, pass Git::Blame::File to the pattern Callable.
Any file with a known extension will be tried, unless overridden by any
explicit extension specification.

These methods can be called on the object passed to the pattern Callable:
- commits  Map of commits, key is SHA1, value if Git::Blame::Commit object
- authors  list of unique authors

These methods can be called on the Git::Blame::Commit object:
- author             the name of the author
- author-mail        the email address of the author
- author-time        a DateTime object for the authoring
- commit             the associated Git::Blame::Commit object
- committed          whether it has been committed already
- committer          the name of the committer
- committer-mail     the email address of the committer
- committer-time     a DateTime object for the committing
- previous-sha1      the full SHA1 of the previous commit
- previous-sha       the shortened SHA1 of the previous commit
- previous-filename  the filename in the previous commit
- sha1               full SHA1 of the commit to which this line belongs
- sha                shortened SHA1 of the commit to which this line belongs
- summary            the first line of the commit message of this line

Example: committers in a repository
$ rak --blame-per-file '*.authors.Slip' --unique

Example: files with more than one commit and number of commits
$ rak --blame-per-file '{ .commits.Int if .commits > 1 }'

--blame-per-line

Attempt to obtain "git blame" information of the file as a Git::Blame::File
object.  If successful, pass each line as a Git::Blame::Line to the pattern
Callable.  Any file with a known extension will be tried, unless overridden
by any explicit extension specification.

Apart from the methods that can be called on the Git::Blame::Commit object,
these additional methods can be called on the object passed to the pattern
Callable:
- commit                the associated Git::Blame::Commit object
- filename              the current filename
- line                  the actual line currently
- line-number           the current line-number
- original-line-number  line number when this line was created

--csv-per-line

Attempt to interprete file as a CSV file, and pass each row as a List to
to the pattern Callable.  Only files with extensions from the C<#csv> group
will be tried, unless overridden by any explicit extension specification.

The following options only make sense when --csv-per-line has been specified:
- --allow-loose-escapes  flag, allow any character to be escaped
- --allow-loose-quotes   flag, allow unquoted fields
- --allow-whitespace     flag, allow whitespace around separator
- --auto-diag            flag, show diagnostics (default: true)
- --eol=[\n|\r|\r\n]     different line ending to assume
- --escape=[\\]          escape character, default \  (shell requires \\)
- --formula=[type]       none | die | diag | empty, default: none
- --quote=["]            quoting char, default: "
- --sep=[,]              field separator, default: ,
- --strict               flag, do not allow different number of fields
- --keep-meta            flag, produce fields as CSV::Field instead of Str

--unicode

Search the Unicode codepoint database (built into Raku) for defined codepoints
by name.  Shows matched codepoint value in hexadecimal, the full name and the
actual character.

Example:
$ rak --unicode banknote
1F4B4 BANKNOTE WITH YEN SIGN ðŸ’´
1F4B5 BANKNOTE WITH DOLLAR SIGN ðŸ’µ
1F4B6 BANKNOTE WITH EURO SIGN ðŸ’¶
1F4B7 BANKNOTE WITH POUND SIGN ðŸ’·
