Pattern specification:
 foo                      literal string
 '/ << bar >> /'          Raku regex indicated by being bounded by / /
 '{ .ends-with("bar") }'  Raku code indicated by being bounded by { }
 '*.starts--with("foo")'  Raku WhateverCode starting with *.
either as first argument, or as --pattern=foo option

String search pattern modifiers:
 --ignorecase  Ignore distinction between upper, lower and title case letters
 --ignoremark  Only compare base characters, ignore additional marks
 --smartcase   As --ignorecase if pattern does NOT contain any uppercase
 --type=words        Look for string as a word
 --type=starts-with  Look for string at start of a line
 --type=ends-with    Look for string at end of a line
 --type=contains     Look for string anywhere (default)

Input selection:
 --find            Interprete selected paths as the lines to inspect
 --json-per-file   Call Raku code with parsed JSON
 --json-per-elem   Call Raku code with top elements of parsed JSON
 --json-per-line   Call Raku code with parsed JSON
 --blame-per-file  Call Raku code with Git::Blame::File objects if possible
 --blame-per-line  Call Raku code with Git::Blame::Line objects if possible
 --csv-per-line    Interpret file as CSV and produce rows
 --unicode         Search the Unicode codepoint database

Code pattern helpers:
 --repository=lib      First look for any modules to load in the "lib" directory
 --module=foo          Load module "foo" before compiling Raku code pattern
 --quietly             Disable warnings when executing pattern (default: False)
 --silently[=out,err]  Capture output when executing pattern (default: False)

Haystack specification:
 path1 path2 ...          All other arguments are paths (default: current dir)
 --paths                  Comma separated list of paths instead of ^^
 --extensions             By group (e.g. #raku) and/or comma separated
 --files-from=file        Read files to inspect from given file
 --known-extensions       Only search files with known extensions
 --paths-from=file        Read path specifications from given file
 --recurse-symlinked-dir  Recurse into symlinked directories? (default: don't)
 --recurse-unmatched-dir  Recurse into directories not matching (default: don't)
 --under-version-control  Only select paths that are under version control
 --dir=expression         Directory basename filter, default: not ^.
 --file=expression        File basename filter, default: all
 --find-all               Override --dir / --file defaults

Filesystem filters:
 --accessed=condition   Check on epoch when file was last accessed
 --blocks               Number of filesystem blocks used by file
 --created=condition    Check on epoch when file was created
 --device-number        Number of device on which file is located
 --exec                 Run program, include if successful
 --filesize             Number of bytes of data used by file
 --hard-links           Number of hard-links to file on filesystem
 --inode                Inode number of file on filesystem
 --group=selector       File is owned by group names / expression
 --gid=condition        File is owned by given gid
 --has-setgid           Has SETGID bit set in attributes
 --has-setuid           Has SETUID bit set in attributes
 --is-empty             File does (not) contain any data
 --is-executable        File can (not) be executed by owner
 --is-readable          File can (not) be read by owner
 --is-writable          File can (not) be written to by owner
 --is-group-executable  File can (not) be executed by group members of owner
 --is-group-readable    File can (not) be read by group members of owner
 --is-group-writable    File can (not) be written to by group members of owner
 --is-owned-by-group    File is (not) owned by group of user
 --is-owned-by-user     File is (not) owned by user
 --is-sticky            Has STICKY bit set in attributes
 --is-symbolic-link     File is (not) a symbolic link
 --is-world-executable  File can (not) be executed by anybody
 --is-world-readable    File can (not) be read by anybody
 --is-world-writable    File can (not) be written to by anybody
 --meta-modified=cond   Check on epoch when meta-info of file was last changed
 --mode                 The full mode value of the file
 --modified=condition   Check on epoch when file was last changed
 --shell                Run shell command, include if successful
 --user=selector        File is owned by user names / expression
 --uid=expression       File is owned by given uid

Result modifiers:
 --context=N               List N lines around any line with a match
 --before-context=N        List N lines before any line with a match
 --after-context=N         List N lines after any line with a match
 --paragraph-context       List all lines in the same paragraph around a match
 --passthru-context        List all lines if there is at least one match
 --passthru                List all lines always
 --invert-match            Select lines that do **not** match
 --max-matches-per-file=N  Maximum number of matches per file, default: all
 --count-only              Only return count of matches
 --stats-only              Only return statistics of the search
 --files-with-matches      Only return filenames with matches
 --files-without-matches   Only return filenames without matches
 --matches-only            Only produce the actual matches
 --unique                  Only return unique lines
 --frequencies             Only return lines and their frequencies

Listing modifiers:
 --human                     Force defaults as if a human is watching
 --absolute                  Show paths as absolute paths
 --break[=string]            String to show between different files
 --group-matches             Show filename only once on a separate line
 --show-blame                Show git blame information if possible
 --show-filename             Show the filename in which match occurred
 --file-separator-null       Separate filenames with null bytes
 --show-line-number          Show the line number in which match occurred
 --summary-if-larger-than=N  Summarize matching line if longer than N chars
 --trim                      Remove whitespace, true if no context
 --highlight                 Highlight matches if possible
 --highlight-before=xxx      String to put before match
 --highlight-after=yyy       String to put after match
 --proximate[=N]             Grouping of matched lines
 --only-first[=N]            Show only the N results, N defaults to 1
 --output-file=filename      Send output to indicated file (default: STDOUT)
 --pager                     Pager to use (default: ACK_PAGER // none)
 --stats                     Also show statistics

Content modifiers:
 --modify-files        Change content of files using the Callable pattern
 --backup[=extension]  Make backup of file with extension (default: .bak)
 --dry-run             Don't actually make any changes, just run the process

Resource usage:
 --batch=N   Max number of files to process in a thread (default: 64)
 --degree=N  Max number of threads to use for processing (default: cores - 1)

Special options:
 --edit[=editor]  Go edit the result in an editor, (default EDITOR or vim)
 --vimgrep        Produce output in :vimgrep format
 --checkout       Checkout branch if pattern matches single branch name

Option management:
 --save=name              Translate --name to all other options specified,
                          remove if --save was the only option specified
 --list-custom-options    List all previously saved options

General options:
 --help      Show this
 --help foo  Show additional help about:
               pattern | string   | code    | haystack | result  | listing
               content | resource | special | option   | general | philosophy
               examples
 --list-known-extensions  Show all known extensions and their groups
 --version                Show version information
 --verbose                Be more verbose, if applicable

Debugging options:
 --dont-catch             Let code exceptions be thrown with backtrace
 --list-expanded-options  List all options given after having been expanded
 --rak                    Show arguments to "rak" plumbing before running

Option format:
 --foo      Option "foo" is True
 --/foo     Option "foo" is False
 --no-foo   Option "foo" is False
 --foo=bar  Option "foo" is "bar"
