Pattern specification:
 foo                      literal string
 '/ << bar >> /'          Raku regex indicated by being bounded by / /
 '{ .ends-with("bar") }'  Raku code indicated by being bounded by { }
 '*.starts--with("foo")'  Raku WhateverCode starting with *.
either as first argument, or as --pattern=foo option

String search pattern modifiers:
 --ignorecase  Ignore distinction between upper, lower and title case letters
 --ignoremark  Only compare base characters, ignore additional marks
 --smartcase   As --ignorecase if pattern does NOT contain any uppercase
 --type=words        Look for string as a word
 --type=starts-with  Look for string at start of a line
 --type=ends-with    Look for string at end of a line
 --type=contains     Look for string anywhere (default)

Input selection:
 --find            Interprete selected paths as the lines to inspect
 --json-per-file   Call Raku code with parsed JSON if file contains JSON
 --json-per-line   Call Raku code with parsed JSON if line contains JSON
 --blame-per-file  Call Raku code with Git::Blame::File objects if possible
 --blame-per-line  Call Raku code with Git::Blame::Line objects if possible
 --csv-per-line    Interpret file as CSV and produce rows

Code pattern helpers:
 --repository=lib      First look for any modules to load in the "lib" directory
 --module=foo          Load module "foo" before compiling Raku code pattern
 --quietly             Disable warnings when executing pattern (default: False)
 --silently[=out,err]  Capture output when executing pattern (default: False)

Haystack specification:
 path1 path2 ...          All other arguments are paths (default: current dir)
 --extensions             By group (e.g. #raku) and/or comma separated
 --files-from=file        Read files to inspect from given file
 --known-extensions       Only search files with known extensions
 --paths-from=file        Read path specifications from given file
 --recurse-symlinked-dir  Recurse into symlinked directories? (default: don't)
 --recurse-unmatched-dir  Recurse into directories not matching (default: don't)

Filesystem filters:
 --is-empty             File does (not) contain any data
 --is-executable        File can (not) be executed by owner
 --is-readable          File can (not) be read by owner
 --is-writable          File can (not) be written to by owner
 --is-symbolic-link     File is (not) a symbolic link
 --is-group-executable  File can (not) be executed by group members of owner
 --is-group-readable    File can (not) be read by group members of owner
 --is-group-writable    File can (not) be written to by group members of owner
 --is-owned-by-group    File is (not) owned by group of user
 --is-owned-by-user     File is (not) owned by user
 --is-world-executable  File can (not) be executed by anybody
 --is-world-readable    File can (not) be read by anybody
 --is-world-writable    File can (not) be written to by anybody

Result modifiers:
 --context=N            List N lines around any line with a match
 --before-context=N     List N lines before any line with a match
 --after-context=N      List N lines after any line with a match
 --paragraph-context    List all lines in the same paragraph around a match
 --passthru-context     List all lines if there is at least one match
 --passthru             List all lines always
 --count-only           Only return count of matches
 --files-with-matches   Only return filenames with matches
 --file-separator-null  Separate filenames with null bytes
 --unique               Only return unique lines
 --frequencies          Only return lines and their frequencies

Listing modifiers:
 --human                     Force defaults as if a human is watching
 --break[=string]            String to show between different files
 --group-matches             Show filename only once on a separate line
 --show-blame                Show git blame information if possible
 --show-filename             Show the filename in which match occurred
 --show-line-number          Show the line number in which match occurred
 --only-matching             Only produce the actual matches
 --summary-if-larger-than=N  Summarize matching line if longer than N chars
 --trim                      Remove whitespace, true if no context
 --highlight                 Highlight matches if possible
 --highlight-before=xxx      String to put before match
 --highlight-after=yyy       String to put after match
 --output-file=filename      Send output to indicated file (default: STDOUT)
 --pager                     Pager to use (default: ACK_PAGER // none)
 --first-only[=N]            Show only the N results, N defaults to 1

Content modifiers:
 --modify-files        Change content of files using the Callable pattern
 --backup[=extension]  Make backup of file with extension (default: .bak)
 --dry-run             Don't actually make any changes, just run the process

Resource usage:
 --batch=N   max number of files to process in a thread (default: 64)
 --degree=N  max number of threads to use for processing (default: cores - 1)

Special options:
 --edit[=editor]  Go edit the result in an editor, (default EDITOR or vim)
 --vimgrep        Produce output in :vimgrep format
 --checkout       Checkout branch if pattern matches single branch name

Option management:
 --save=name              Translate --name to all other options specified,
                          remove if --save was the only option specified
 --list-custom-options    List all previously saved options
 --list-expanded-options  List all options given after having been expanded

General options:
 --help      Show this
 --help foo  Show additional help about:
               pattern | string   | code    | haystack | result  | listing
               content | resource | special | option   | general | philosophy
               examples
 --list-known-extensions  Show all known extensions and their groups
 --version                Show version information
 --verbose                Be more verbose, if applicable

Option format:
 --foo      Option "foo" is True
 --/foo     Option "foo" is False
 --no-foo   Option "foo" is False
 --foo=bar  Option "foo" is "bar"
